#
# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.
#
"""
DB schema definition for the :py:class:`~mlos_bench.storage.sql.storage.SqlStorage`
backend.

Notes
-----
The SQL statements are generated by SQLAlchemy, but can be obtained using
``repr`` or ``str`` (e.g., via ``print()``) on this object.
The ``mlos_bench`` CLI will do this automatically if the logging level is set to
``DEBUG``.

Also see the `mlos_bench CLI usage <../../../../../mlos_bench.run.usage.html>`__ for
details on how to invoke only the schema creation/update routines.
"""

import logging
from importlib.resources import files
from typing import Any

from alembic import command, config
from sqlalchemy import (
    Column,
    Connection,
    DateTime,
    Dialect,
    Float,
    ForeignKeyConstraint,
    Integer,
    MetaData,
    PrimaryKeyConstraint,
    Sequence,
    String,
    Table,
    UniqueConstraint,
    create_mock_engine,
    inspect,
)
from sqlalchemy.dialects import mysql
from sqlalchemy.engine import Engine

from mlos_bench.util import path_join

_LOG = logging.getLogger(__name__)


def _mysql_datetime_with_fsp() -> mysql.DATETIME:
    """
    Return a MySQL DATETIME type with fractional seconds precision (fsp=6).

    Notes
    -----
    Split out to allow single mypy ignore.
    See <https://github.com/sqlalchemy/sqlalchemy/pull/12164> for details.
    """
    return mysql.DATETIME(fsp=6)


class _DDL:
    """
    A helper class to capture the DDL statements from SQLAlchemy.

    It is used in `DbSchema.__str__()` method below.
    """

    def __init__(self, dialect: Dialect):
        self._dialect = dialect
        self.statements: list[str] = []

    def __call__(self, sql: Any, *_args: Any, **_kwargs: Any) -> None:
        self.statements.append(str(sql.compile(dialect=self._dialect)))

    def __repr__(self) -> str:
        res = ";\n".join(self.statements)
        return res + ";" if res else ""


class DbSchema:
    """A class to define and create the DB schema."""

    # This class is internal to SqlStorage and is mostly a struct
    # for all DB tables, so it's ok to disable the warnings.
    # pylint: disable=too-many-instance-attributes

    def __init__(self, engine: Engine):
        """
        Declare the SQLAlchemy schema for the database.

        Parameters
        ----------
        engine : sqlalchemy.engine.Engine
        """
        assert engine, "Error: can't create schema without engine."
        _LOG.info("Create the DB schema for: %s", engine)
        self._engine = engine
        self._meta = MetaData()

        # Common string column sizes.
        self._exp_id_len = 512
        self._param_id_len = 512
        self._param_value_len = 1024
        self._metric_id_len = 512
        self._metric_value_len = 255
        self._status_len = 16

        # Some overrides for certain DB engines:
        if engine and engine.dialect.name in {"mysql", "mariadb"}:
            self._exp_id_len = 255
            self._param_id_len = 255
            self._metric_id_len = 255

        self.experiment = Table(
            "experiment",
            self._meta,
            Column("exp_id", String(self._exp_id_len), nullable=False),
            Column("description", String(1024)),
            Column("root_env_config", String(1024), nullable=False),
            Column("git_repo", String(1024), nullable=False),
            Column("git_commit", String(40), nullable=False),
            # For backwards compatibility, we allow NULL for ts_start.
            Column(
                "ts_start",
                DateTime(timezone=True).with_variant(
                    _mysql_datetime_with_fsp(),
                    "mysql",
                ),
            ),
            Column(
                "ts_end",
                DateTime(timezone=True).with_variant(
                    _mysql_datetime_with_fsp(),
                    "mysql",
                ),
            ),
            # Should match the text IDs of `mlos_bench.environments.Status` enum:
            # For backwards compatibility, we allow NULL for status.
            Column("status", String(self._status_len)),
            # There may be more than one mlos_benchd_service running on different hosts.
            # This column stores the host/container name of the driver that
            # picked up the experiment.
            # They should use a transaction to update it to their own hostname when
            # they start if and only if its NULL.
            Column("driver_name", String(40), comment="Driver Host/Container Name"),
            Column("driver_pid", Integer, comment="Driver Process ID"),
            PrimaryKeyConstraint("exp_id"),
        )
        """The Table storing
        :py:class:`~mlos_bench.storage.base_experiment_data.ExperimentData` info.
        """

        self.objectives = Table(
            "objectives",
            self._meta,
            Column("exp_id"),
            Column("optimization_target", String(self._metric_id_len), nullable=False),
            Column("optimization_direction", String(4), nullable=False),
            # TODO: Note: weight is not fully supported yet as currently
            # multi-objective is expected to explore each objective equally.
            # Will need to adjust the insert and return values to support this
            # eventually.
            Column("weight", Float, nullable=True),
            PrimaryKeyConstraint("exp_id", "optimization_target"),
            ForeignKeyConstraint(["exp_id"], [self.experiment.c.exp_id]),
        )
        """The Table storing
        :py:class:`~mlos_bench.storage.base_storage.Storage.Experiment` optimization
        objectives info.
        """

        # A workaround for SQLAlchemy issue with autoincrement in DuckDB:
        if engine and engine.dialect.name == "duckdb":
            seq_config_id = Sequence("seq_config_id")
            col_config_id = Column(
                "config_id",
                Integer,
                seq_config_id,
                server_default=seq_config_id.next_value(),
                nullable=False,
                primary_key=True,
            )
        else:
            col_config_id = Column(
                "config_id",
                Integer,
                nullable=False,
                primary_key=True,
                autoincrement=True,
            )

        self.config = Table(
            "config",
            self._meta,
            col_config_id,
            Column("config_hash", String(64), nullable=False, unique=True),
        )
        """The Table storing
        :py:class:`~mlos_bench.storage.base_tunable_config_data.TunableConfigData`
        info.
        """

        self.trial = Table(
            "trial",
            self._meta,
            Column("exp_id", String(self._exp_id_len), nullable=False),
            Column("trial_id", Integer, nullable=False),
            Column("config_id", Integer, nullable=False),
            Column("trial_runner_id", Integer, nullable=True, default=None),
            Column(
                "ts_start",
                DateTime(timezone=True).with_variant(
                    _mysql_datetime_with_fsp(),
                    "mysql",
                ),
                nullable=False,
            ),
            Column(
                "ts_end",
                DateTime(timezone=True).with_variant(
                    _mysql_datetime_with_fsp(),
                    "mysql",
                ),
                nullable=True,
            ),
            # Should match the text IDs of `mlos_bench.environments.Status` enum:
            Column("status", String(self._status_len), nullable=False),
            PrimaryKeyConstraint("exp_id", "trial_id"),
            ForeignKeyConstraint(["exp_id"], [self.experiment.c.exp_id]),
            ForeignKeyConstraint(["config_id"], [self.config.c.config_id]),
        )
        """The Table storing :py:class:`~mlos_bench.storage.base_trial_data.TrialData`
        info.
        """

        # Values of the tunable parameters of the experiment,
        # fixed for a particular trial config.
        self.config_param = Table(
            "config_param",
            self._meta,
            Column("config_id", Integer, nullable=False),
            Column("param_id", String(self._param_id_len), nullable=False),
            Column("param_value", String(self._param_value_len)),
            PrimaryKeyConstraint("config_id", "param_id"),
            ForeignKeyConstraint(["config_id"], [self.config.c.config_id]),
        )
        """The Table storing
        :py:class:`~mlos_bench.storage.base_tunable_config_data.TunableConfigData`
        info.
        """

        # Values of additional non-tunable parameters of the trial,
        # e.g., scheduled execution time, VM name / location, number of repeats, etc.
        self.trial_param = Table(
            "trial_param",
            self._meta,
            Column("exp_id", String(self._exp_id_len), nullable=False),
            Column("trial_id", Integer, nullable=False),
            Column("param_id", String(self._param_id_len), nullable=False),
            Column("param_value", String(self._param_value_len)),
            PrimaryKeyConstraint("exp_id", "trial_id", "param_id"),
            ForeignKeyConstraint(
                ["exp_id", "trial_id"],
                [self.trial.c.exp_id, self.trial.c.trial_id],
            ),
        )
        """The Table storing :py:class:`~mlos_bench.storage.base_trial_data.TrialData`
        :py:attr:`metadata <mlos_bench.storage.base_trial_data.TrialData.metadata_dict>`
        info.
        """

        self.trial_status = Table(
            "trial_status",
            self._meta,
            Column("exp_id", String(self._exp_id_len), nullable=False),
            Column("trial_id", Integer, nullable=False),
            Column(
                "ts",
                DateTime(timezone=True).with_variant(
                    _mysql_datetime_with_fsp(),
                    "mysql",
                ),
                nullable=False,
                default="now",
            ),
            Column("status", String(self._status_len), nullable=False),
            UniqueConstraint("exp_id", "trial_id", "ts"),
            ForeignKeyConstraint(
                ["exp_id", "trial_id"],
                [self.trial.c.exp_id, self.trial.c.trial_id],
            ),
        )
        """The Table storing :py:class:`~mlos_bench.storage.base_trial_data.TrialData`
        :py:class:`~mlos_bench.environments.status.Status` info.
        """

        self.trial_result = Table(
            "trial_result",
            self._meta,
            Column("exp_id", String(self._exp_id_len), nullable=False),
            Column("trial_id", Integer, nullable=False),
            Column("metric_id", String(self._metric_id_len), nullable=False),
            Column("metric_value", String(self._metric_value_len)),
            PrimaryKeyConstraint("exp_id", "trial_id", "metric_id"),
            ForeignKeyConstraint(
                ["exp_id", "trial_id"],
                [self.trial.c.exp_id, self.trial.c.trial_id],
            ),
        )
        """The Table storing :py:class:`~mlos_bench.storage.base_trial_data.TrialData`
        :py:attr:`results <mlos_bench.storage.base_trial_data.TrialData.results_dict>`
        info.
        """

        self.trial_telemetry = Table(
            "trial_telemetry",
            self._meta,
            Column("exp_id", String(self._exp_id_len), nullable=False),
            Column("trial_id", Integer, nullable=False),
            Column(
                "ts",
                DateTime(timezone=True).with_variant(
                    _mysql_datetime_with_fsp(),
                    "mysql",
                ),
                nullable=False,
                default="now",
            ),
            Column("metric_id", String(self._metric_id_len), nullable=False),
            Column("metric_value", String(self._metric_value_len)),
            UniqueConstraint("exp_id", "trial_id", "ts", "metric_id"),
            ForeignKeyConstraint(
                ["exp_id", "trial_id"],
                [self.trial.c.exp_id, self.trial.c.trial_id],
            ),
        )
        """The Table storing :py:class:`~mlos_bench.storage.base_trial_data.TrialData`
        :py:attr:`telemetry <mlos_bench.storage.base_trial_data.TrialData.telemetry_df>`
        info.
        """

        _LOG.debug("Schema: %s", self._meta)

    @property
    def meta(self) -> MetaData:
        """Return the SQLAlchemy MetaData object."""
        return self._meta

    def _get_alembic_cfg(self, conn: Connection) -> config.Config:
        alembic_cfg = config.Config(
            path_join(str(files("mlos_bench.storage.sql")), "alembic.ini", abs_path=True)
        )
        assert self._engine is not None
        alembic_cfg.set_main_option(
            "sqlalchemy.url",
            self._engine.url.render_as_string(
                hide_password=False,
            ),
        )
        alembic_cfg.attributes["connection"] = conn
        return alembic_cfg

    def drop_all_tables(self, *, force: bool = False) -> None:
        """
        Helper method used in testing to reset the DB schema.

        Notes
        -----
        This method is not intended for production use, as it will drop all tables
        in the database. Use with caution.

        Parameters
        ----------
        force : bool
            If True, drop all tables in the target database.
            If False, this method will not drop any tables and will log a warning.
        """
        assert self._engine
        self.meta.reflect(bind=self._engine)
        if force:
            self.meta.drop_all(bind=self._engine)
        else:
            _LOG.warning(
                "Resetting the schema without force is not implemented. "
                "Use force=True to drop all tables."
            )

    def create(self) -> "DbSchema":
        """Create the DB schema."""
        _LOG.info("Create the DB schema")
        assert self._engine
        self._meta.create_all(self._engine)
        with self._engine.begin() as conn:
            # If the trial table has the trial_runner_id column but no
            # "alembic_version" table, then the schema is up to date as of initial
            # create and we should mark it as such to avoid trying to run the
            # (non-idempotent) upgrade scripts.
            # Otherwise, either we already have an alembic_version table and can
            # safely run the necessary upgrades or we are missing the
            # trial_runner_id column (the first to introduce schema updates) and
            # should run the upgrades.
            if any(
                column["name"] == "trial_runner_id"
                for column in inspect(conn).get_columns(self.trial.name)
            ) and not inspect(conn).has_table("alembic_version"):
                # Mark the schema as up to date.
                alembic_cfg = self._get_alembic_cfg(conn)
                command.stamp(alembic_cfg, "heads")
                # command.current(alembic_cfg)
        return self

    def update(self) -> "DbSchema":
        """
        Updates the DB schema to the latest version.

        Notes
        -----
        Also see the `mlos_bench CLI usage <../../../../../mlos_bench.run.usage.html>`__
        for details on how to invoke only the schema creation/update routines.
        """
        assert self._engine
        with self._engine.connect() as conn:
            alembic_cfg = self._get_alembic_cfg(conn)
            command.upgrade(alembic_cfg, "head")
        return self

    def __repr__(self) -> str:
        """
        Produce a string with all SQL statements required to create the schema from
        scratch in current SQL dialect.

        That is, return a collection of CREATE TABLE statements and such.
        NOTE: this method is quite heavy! We use it only once at startup
        to log the schema, and if the logging level is set to DEBUG.

        Returns
        -------
        sql : str
            A multi-line string with SQL statements to create the DB schema from scratch.
        """
        assert self._engine
        ddl = _DDL(self._engine.dialect)
        mock_engine = create_mock_engine(self._engine.url, executor=ddl)
        self._meta.create_all(mock_engine, checkfirst=False)
        return str(ddl)
